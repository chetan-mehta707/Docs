ayush.singh@samsung.com,
mani111ece@gmail.com,
sunil.pandey@samsung.com,
sunilrpandey@gmail.com,

install python2.7  or python3.4

1) samsung app store
2) shared folder
3) www.python.org
4) www.activestate.com
5) anaconda.org       - ml


Python installation FOLDER:-
============================
1) c:\users\LOGINNAME\appdata\local\programs\python36-32\python
2) c:\users\LOGINNAME\appdata\local\continnum\anaconda2

1) C:\python2.7

python.exe
pythonw.exe

c:\python27\scripts>

pip.exe
pip2.exe
pip2.7.exe
easy_install.exe


1) www.python.org      - compiler+debugger+help+Libs+Tools+IDLE
2) www.activestate.com - compiler+debugger+help+Libs+Tools+IDLE
3) anaconda.org        - datascience/ML/CV - libs required for datasci
                         pre loaded - spyder + IpythonNoteBook


>>Procedural Lang         - functions
>>Modular lang            - group fns
>>Object Oriented Lang    - classes & objects
>>Dynamic Lang / metaprogramming - template programming
>>Functional programming  - maths


Object Based scripting Lang:-
=============================
Class        - blue print
Object       - instance of a class
Data Members - data on object
MEthods      - functionality on object
getter       - reads the data
setter       - modifies the data
mutating     - changes the state of the object
non-mutating - does't change the state of the object
state        - change in data members
message passing - invoking the methods

Run Time          - dynamic
Compile Time      - static
Memory allocation - static/dyamic - new/gc  - implicitlty in py-dynamic 

REferences
Im-Mutable
Mutable

Reference counting
Shallow Copy/Deep Copy
Garbage Collector 


python treats 
 small integers
 big integers

 small strings
 big strings



Object Diagonstics:-
====================
print(num)
print(id(num))  
print(type(num))

import sys

print(sys.getsizeof(num))     # num.__sizeof__()
print(sys.getrefcount(num))



Python Implementations:-
========================

Using "C"       - CPython
using "JAVA"    - Jython
using "C#"      - IronPython
using "C & CPy" - Stacklesspython
using "CPython" - pypy
using "RPython" - micro python
using "CPython" - Numba

know which implementation of python u r using:-
===============================================
import sys

print(sys.subversion)      # python2
print(sys.implementation)  # python3



                     python
                       |
        -------------------------------
       |                               |
     2.x                             3.x
     2.4                             3.4
     2.6                             3.5
     2.7.x                           3.6.x


>>2to3.exe    - convert python2 syntax to python3 syntax
>>lib2to3.exe - convert py2 library to support python3
>>Parallel Development
>>Syntax Differences
>>Library support differs
>>Libraries are renamed/discontinued
>>add features/deleted features
>>more matured 
>>py 3 feature rich



Basic keyboard input function:-
================================

a = raw_input("Enter the value : ")   # py2
a = input("Enter the value : ")       # py3


Note:
always the above fns return - string

Basic CONSOLE OUTPUT:-
======================

print "Hello value  ",a    # py2
print("Hello value  ",a)   # py3


a=10
b=20
c=a*b
print("Hello %s %s %s " %(a,b,c))
print("Hello {0} {1} {2}".format(a,b,c))
print("Hello ",a,b,c)
print("Helllo "+str(a))
print("Hello "+repr(a))




Type Conversion:-
=================
>> parameterized constructors

str(object)
int(object)
float(object)
list(object)
tuple(object)
set(object)
dict(object)

a = int(input("Enter ur value : "))  # perm conversion

c = int(a) + 5                       # Temp Conversion - Anon Objects



Rules:-
========
Coding Standard - pep8.org

1) all u r variable names shld be in lowercase
2) variable=10
   _variable=20
   __variable=30   # USER DEFINED
3) _variable_
   __variable__    # never use this INBUILT 
4) never use PYTHON API fns as user defined variables
5) program shld have extension ".PY"
6) Don't use LIBRARY names as program names
7) comments in python starts with - #
8) NEver save u r program in the installation FOLDER
   [ i will be treated as LIBRARY
     LIBRARY Search will slow down
     for windows USERS ]


write a program to add 2 nos
output look like this

sum of 10 and 20 is 30


===========================================================================
int-class:-
===========
1)
a=10       # decimal
b=0b1100   # binary number stored as decimal
c=0xFFFF   # hexa number stored as decimal
d=0O123    # octal number stored as decimal

2)
print(bin(a))  # integer to Binary STring
print(oct(a))  # integer to OCtal STring
print(hex(a))  # integer to Hexa String


3)
data="1101"   # convert this to integer class object
              # data is in BINARY SYSTEM
res = int(data,base=2)


4)
num=12245     # we need the first digit 
              # we need the last digit

print(str(num)[0]) 
print(str(num)[-1]) 


===========================================================================
str-class:-
===========
>> collection of alph-numeric values
>> im-mutable
>> default char set in py2 - ASCII
>> default char set in py3 - UNICODE


a="hello"                   # default char set is UNICODE
b=bytes(a,encoding="utf-8") # unicode string converted to bytestring


b=bytes(a,encoding="utf-8") # unicode string converted to bytestring
c=b.decode("utf-8")         # bytestring converted to unicode string

Diff ways to define a string:-
==============================
a='hello world'    # single quoted -\n\t will be interpolated
a="hello world"    # double quoted -\n\t will be interpolated
a='''hello         # multi line str triple quotes --\n\t 
  world'''
a=r'10\n20\n30'    # WYSIWG
a=R'10\n20\n30'    # WYSIWG




1) length string       :  len(a)
2) first char          :  a[0]
3) last char           :  a[len(a)-1] or a[-1]
4) first 4 elements    :  a[:4]
5) Except first 4      :  a[4:]
6) last 4 elements     :  a[-4:]
7) Except last 4       :  a[:-4]
8) EF4 & EL4           :  a[4:-4]
9) alt chars           :  a[::2]
10)alt chars           :  a[1::2]
11)reverse             :  a[::-1]
12)concatenate         :  c=a+b
13)upper               :  c=a.upper() # modified copy/actual
14)replace             :  c=a.replace("blore","blr")#modified copy/actual
15)trim                :  c=a.strip() / a.lstrip() / a.rstrip()
16)search              :  res="word" in a 
17)search              :  res=a.index("word")
18)count               :  res=a.count("Word")
19)split               :  flst = a.split(DELIMTER)
20)join                :  res = "delimiter".join(strlist)


ex:
===
name = input("Enter u r name : ")

#first letter the name shld be converted uppercase
res = name[0].upper() + name[1:]

print("OLD = ",name)
print("NEW = ",res)

"ramesh"
"RamesH"  first letter & last letter shld converted to upper
          in b/w chars let it be as it is
res=name[0].upper() + name[1:-1] + name[-1].upper()


"ramesh"
"RAmeSH"  first2 letter & last2 letter shld converted to upper
          in b/w chars let it be as it is

res=name[0:2].upper() + name[2:-2] + name[-2:].upper()

"ramesh"
"RsemaH   first letter & last letter shld converted to upper
          in b/w chars shld be reversed

res=name[0].upper() + name[1:-1][::-1] + name[-1].upper()
res=name[0].upper() + name[-2:0:-1] + name[-1].upper()



name="hari prasad"

#convert the firstname first letter to uppercase
#convert the secondname first letter to uppercase

wlst = name.split()
print(wlst[0][0].upper()+wlst[0][1:]+" "....)
or
first,last = name.split()
print(first[0].upper()+first[1:]+" "+second[0].upper()+second[1:])



a="10-20-30-40"

alst = a.split("-")

b="-".join(alst)  # note it can join only strings



Given:-
========
a="10-15-30-50-55"

Expected:
=========
b="11-16-31-51-56"

sol:-
=====
b = "-".join([str(int(elem)+1)  for elem in a.split("-")])

wlst = a.split("-")

#reslst = map(lambda/fn-name, LISTNAME)
reslst = map(lambda x: str(int(x)+1), wlst)
b = "-".join(reslst)

===========================================================================
if-else:-
=========
>> there is no flower braces
>> else if - elif
>> &&      - and
>> ||      - or
>> !       - not


sent=input("sentence : ")

# compare the first & last word

if sent.split()[0] == sent.split()[-1]:
   print("first & last words are equal")
else:
   print("first & last words are not equal") 


write a program to accept a char from the user
check is it a vowel/consonant


char = input("Enter a char : ")

if char.lower() in "aeiou":
  print("Vowel")
else:
  print("Conso")



write a program to accept a number from the user
check is it a ARMSTRONG number

 371 = 27 + 343 + 1






How to generate natural integers in python:-
============================================
>> in Python2.x   - range() & xrange()
>> in Python3.x   - range()
>> works only with int's
>> returns a LIST of numbers/iterables
>> default start - 0
   default step  - 1

range(start,stop-1)
range(start,stop-1,step)
range(stop-1)


range(8,21,4) - [8,12,16,20]
range(1,8)    - [1,2,3,4,5,6,7]
range(6,0,-1) - [6,5,4,3,2,1]
range(5)      - [0,1,2,3,4]
range(1,10,2) - [1,3,5,7,9]
range(0,9,2)  - [0,2,4,6,8]





                   py2
     --------------------------------------  
    |                                      |

range()                       		xrange()

allocates memory for every int		alloc only on DEMAND

range(1,11)

how many integers - 10 x 4 
metadata          - 20 bytes

range(1,11) - 40 + 20    on 32bit
range(1,11) - 80 + 40    on 32bit

range(1,11).__sizeof__()



Note:
In python3 discontinued "range() of py2"
and renamed "xrange() as range()" in py3

py3 range()






Iteration Protocol:-
====================
>> Collections
>> visit every element in the collection - TRAVERSAL
>> where to start from
>> how to move ahead/behind
>> where to stop  - exception "StopIteration"

>>Iterables
>>Iterator


it = iter([10,20,30,40,50])

print(next(it)) # 10            ##### MEthod1#######
print(next(it)) # 20
print(next(it)) # 30
print(next(it)) # 40
print(next(it)) # 50
print(next(it)) # StopIteration


print(*it)                     ###### method2 works only in py3#######

alst = list(it)                ###### method3 #############

##### method4 #### for iterator


for-iterator:-
=============
ex1: # value based iterator
     # const forward iterator
     # read only

numlst=[10,20,30,40,50]   

for elem in numlst:
    ans = elem*elem
    print(elem,ans)

#########################################################################
ex2: # index based iterator
     # read & write

numlst=[10,20,30,40,50]   
for index in range(len(numlst)):
    numlst[index] = numlst[index] ** 2

#########################################################################
ex3: # parallel iterator - truncate to the SMALLEST list
     # read only
alst = ["arun","ravi","hari","amit","ayush","anil","amar"]
blst = [10,20,30,40]

for elem1,elem2 in zip(alst,blst):
   print(elem1,elem2)

#########################################################################
******in this it will not truncate the list******

import itertools

for e1,e2 in itertools.izip_longest(alst,blst,fillvalue=0):  # python2
for e1,e2 in itertools.zip_longest(alst,blst,fillvalue=0):   # python3
  print(e1,e2)


==========================================================================
break
continue
for-else:
while

==========================================================================
tuple-class:-
=============
>> const collection
>> im-mutable
>> faster than list
>> can be used as DICT-key


define a        :  a=(10,20,30,40,50)
                :  a=10,20,30,40,50
length          :  len(a)
is it valid     :  a[0] = 33    # partial modification are not allowed
search for 40   :  40 in a
first elem      :  a[0]
first 4         :  a[:4]
compare 2 tuple :  if a==b:
merge 2 tuple   :  c=a+b
iterate         :  for elem in a:
                     print(elem)

tuple unpacking:-
-----------------
1)
a,b,c = 10,20,30

a,b,*c = 10,20,30,40,50,60   # feature of py3
a,*b,c = 10,20,30,40,50,60   # feature of py3
*a,b,c = 10,20,30,40,50,60   # feature of py3

2)
a,b = 10,20
a,b = b,a     # swap

3)
print("Hello %s %s %s" %(a,b,c))

4)
dob="10-jan-2015"
day,month,year = dob.split("-")   # list unpacking



list-class:-
============
>> collection
>> mutable 


define a empty     : a=[]
define             : a=[10,20,30,40,50]
is it valid        : a[0] = 33       # allowed
is it valid        : a[0:4] = "*" 
list mult          : a = [None] * 5
length             : len(a)
search 40          : if 40 in a

append             : a.append(60)       # mutating
add more           : a.extend([70,80])  # mutating
insert             : a.insert(index,value)

del based on index : a.pop(index)
del based on value : a.remove(40)  # first occurance
del slice          : del a[0:4]

sort asc order     : a.sort()              # IN PLACE Sort
sort desc order    : a.sort(reverse=True) 
reverse            : a.reverse()
sum/max/min        : sum(a)/max(a)/min(a) 

==========================================================================
ex1:
namelst=["arun-kumar", "ravi-sharma", "ranjit-singh", "sri-jois"]

display only the first names/collect all the first names in anotherlist

emptylst = []
for name in namelst:
   flst = name.split()
   emptylst.append(flst[0])

print(emptylst)



ex2:
data = [
         [10,20,30],
         [40,50,60],
         [70,80,90]
       ]
display the first element of each list

for sublst in data:
   print(sublst[0])


ex3:

numlst = [10,20,30,40,50,60]
swap the nos

reslst = [20,10,40,30,60,50]

reslst=[]
for i in range(0,len(numlst),2):
  reslst.append(numlst[i+1])
  reslst.append(numlst[i])

print(reslst)

OR
numlst = [10,20,30,40,50,60]
reslst=[]
for v1,v2 in zip(numlst[::2], numlst[1::2]):
  reslst.extend([v2,v1])
print(reslst)



ex4
numlst = [10,20,30,40,50,60,70,80,90]

steplst = [1,2,3] * len(numlst)//len(steplst)

for v1,v2 in zip(numlst,steplst):
  print(v1+v2)

==========================================================================

                           Data Structure:
                                 |
           ---------------------------------------------
          |                                             |
       Seqeunces                                  Non-sequences

       str					  set
       tuple					  dict
       list
  

==========================================================================
set-class:-
===========
>> collection of unique im-mutable values
>> duplicates are auto deleted
>> unordered - non-sequences
>> mutable

define a empty set    :  a=set()
define                :  a={10,20,30,40,50}
                      :  b=set([30,60,80,44])
length                :  len(a)
search 40             :  if 40 in a
add one elem          :  a.add(50)
delete                :  a.remove(40)
union                 :  a.union(b)        # a|b
intersection          :  a.intersection(b) # a&b
diff                  :  a.difference(b)        # a-b
uncommon              :  a^b

team1 = ["arun","ravi","john","mani","hari"]
team2 = ["guru","manoj","raja","arun","hari"]

find who all are the common in team1 and team2 - need results in LIST
how many are uncommon in team1 & team2

sol:
----
set1 = set(team1)
set2 = set(team2)
common = list(set1 & set2)
uncomm = len(set1 ^ set2)
print(common)
print(uncomm)


===========================================================================

dict-class:-
============
>> lookup table
>> collection of key-value pairs
>> non-seq or unordered
>> mutable
>> hashes/htable/hashmap/map

1) define a empty dict   : colors={}
2) define values         : colors={"blue":10,"orange":20}
3) length                : len(colors)
4) search for "red"      : if "red" in colors
5) get value of "blue"   : colors["blue"]
6) overwrite "orange"    : colors["orange"] = 55
7) create new key-val    : colors["red"] = 44  #### Autovivify####
8) delete "blue"         : colors.pop("blue") / del colors["blue"]
9) compare 2 dicts       : if a==b
10)merge 2 dicts         : c={**a,**b}  # works only in python3
                         : c={}
                           c.update(a)
                           c.update(b)
11) iterate              : for k in colors:
                             print(k,colors[k])
   
                         : for k,v in colors.items():
                             print(k,v)

===========================================================================

example:-
=========
foodmenu = {"idly": 20, "upma":15 }

selection = input("Enter the item : ").lower()

if selection in foodmenu:
  print(selection,foodmenu[selection])
else:
  print("not found") 
  print(foodmenu.keys())

===========================================================================
studlst = [
           "ravi-cse",
           "manu-ece",
           "yash-mec",
           "guru-civ",
           "elan-ele"
          ]

can u prepare a dict out of studlst data ?

studsdict = {}    # define a empty dict first
for stud in stulst:
   name,dept = stud.split("-")
   studsdict[name] = dept
   #studsdict.update({name:dept}) 
   
print(studsdict)

-------------------------------------------------------------------------
custom sorts:-
==============

import pprint

emplst = [
          "arun-sales-blr-53234",
          "john-purch-chn-32323",
          "ravi-accts-hyd-54235",
          "john-sales-tvm-43434"
         ]

emplst.sort(key=lambda record : int(record.split("-")[-1]) )

pprint.pprint(emplst)

ex2:
#multi-key sorting

def anyfun(x):
   name,dept,loc,sal = x.split("-")
   return dept,int(sal)



emplst = [
          "arun-sales-blr-53234",
          "john-purch-chn-32323",
          "ravi-accts-hyd-54235",
          "john-sales-tvm-43434",
          "manu-sales-blr-65656",
          "rani-sales-mum-23435",
          "hari-purcj-blr-65656",
          "ramu-accts-blr-34343",
         ]
emplst.sort(key=anyfun)

print("\n".join(emplst))

==========================================================================
Nested DS:-
===========

a = [ (10,20,30,40), (50,60,70,80) ]

a = [
     [1,2,3],
     [4,5,6]
     [7,8,9]
    ]

a={
   "arun" : [10,20,30],
   "ravi" : [40,50,60]
  }

a = {
     "north" : {"loc":"delhi","team" : ["a","b","c","d"] },
     "south" : {"loc":"blr"  ,"team" : ["x","y","z"]  }
    }




get the first team meber of north ?

a["north"]["team"][0]

how many are there in south team
len(a["south"]["team"]


JSON
YAML
QML
PERL
Ruby
MONgoDB

Extended DS:-
=============

import array

arr = array.array("i")
arr.append(40)
arr.append(10)

print(arr)


import bisect
import heapq

import collections

alst=[10,20,30,10,50,20,40,10,30,20,10]

freqcnt = collections.Counter(alst)

print(freqcnt)

print(freqcnt.most_common(1))

===========================================================================
How to install a library :-
===========================
C:\> pip install numpy



C:\> pip install Modulename          

C:\> pip uninstall Modulename

C:\> pip upgrade Modulename

C:\> pip list

OR

C:\> easy_install Modulename


Intro to Numpy:-
================
>> numpy is written in "C" module - available in python - Cython
>> vectorization & memory mgmt makes it faster
>> nearly 150 times faster than actual python code
>> same data-type
>> pre-req module
    datasci
    Data Analytics
    ML
    Natural Lang processing
    Image processing
    pyGame
    Complex Maths
    Graphs - visualization
>> Similar - MATLAB, SAS, Octave, & other LAngs



import numpy as np

arr = np.array([10,40,30,60,50])  # uniDim Array

m1  = np.array([[32,43,23],[23,65,82],[32,65,13]])  # 2D Array

a   = np.array([[[1,2],[3,4]],[[5,6],[7,8]]])        # 3D array

print arr
print m1
print a


ex:
import numpy as np

m1  = np.array([[32,43,23],[23,65,82],[35,65,13]])  # 2D Array
m2  = np.array([[1,2,3],[4,5,6],[7,8,9]])           # 2D Array

print(m1 + 5)
print(m1.sum())
print(m1.cumsum())
print(m1.mean())
print(m1.diagonal())
print(m1.tranpose())

res = m1 + m2
res = m1.dot(m2)   # matrix multp
print(m1>=20)
print(m1[m1>=20])


# print the first element of each row
prin(m1[:,0])  # numpy array slicing

print(m1.shape)
print(m1.dtype)

m2 = m1.astype('float')
print(m2)

print(np.arange(1,6,.5))   # specify step value as float


===========================================================================
Files:-
=======
>> Store the data in the TEXT FIle
>> Text Mode Files    
>> Binary Mode Files
>> 3 ref points
   BOF - 0
   CUR - 1
   EOF - 2
>> Diff modes 
    r/rb   - readonly    - BOF   - retained - error
    w/wb   - ovewrite    - BOF   - lost     - create new
    a/ab   - append      - EOF   - retained - create new
    r+/rb+ - read-write  - BOF   - retained - error
    w+/wb+ - over-read   - BOF   - lost     - create new
    a+/ab+ - app-read    - EOF   - retained - create new
>> filehandler.seek(No_of_Bytes, REFPOINT)
   handler.seek(25, 0 ) 
   handler.seek(0,0)     # seek to BOF
   handler.seek(0,2)     # Seek to EOF

>> filehandler.tell()   # returns curr position in bytes



f1 = open("new.txt","w")

f1.write("10 20 30\n")
f1.write("40 50 60\n")
f1.write("70 80 90")

f1.close()


f2 = open("new.txt","r")

for elem in f2:                # reads the file line by line
   elem = elem.strip("\n")
   print(elem)

f2.close()



other fns:-
===========
string = fob.read()     # reads complete files & Returns it as a string
string = fob.read(1024) # read block by block
string = fob.readline() # reads upto \n or EOF

lst    = fob.readlines() # reads complete file & returns a list



guess:-
=======
fob = open("data.txt","w+")

fob.write("10\n")
fob.write("20\n")
fob.write("30\n")
fob.write("40\n")
fob.write("50")

#fob.seek(0,0)

for elem in fob:
   print("Hello",elem)

fob.close()


===========================================================================
try this:-
==========

source = input("Enter the filename : ")
dest   = input("Enter the filename : ")

f1 = open(source,"r")
f2 = open(dest,"w")

f2.write(f1.read())

f1.close()
f2.close()
===========================================================================
File existance check:-
======================
import os
import sys

if os.path.isfile("one.txt"):
   print("file exists")
else:
   print("File not found")
   sys.exit(0)



Auto close a file:-
====================
>> context manager
>> using "with" keyword
>> once the control exits out of the block
   the file will be automatically closed


with open("new.txt","r") as fob:
  res = fob.read()
  print(res)


==========================================================================

import pickle

data={
      "one" : 10,
      "two" : [1,2,3]
     }

fob = open("data.pickle","wb")
pickle.dump(data,fob)
fob.close()

==========================================================================
Database programming:-
======================
>> works with SQL's
>> gels more with No-SQL's
>> ORM - SQLAlchemy


1) Connect to server
2) Create a Cursor
3) Prepare the Query - CRUD
4) Execute Query
5) Commit
6) Display the REsultset
7) Close the connection

import sqlite3

try:
    con = sqlite3.connect("some.db")
    cur = con.cursor()
    cur.execute('''create table if not exists emps(name text,
                                                   dept text,
                                                   sal number)''') 
    cur.execute("insert into emps values('arun1','sales',150000)")
    cur.execute("insert into emps values('arun2','sales',150000)")
    cur.execute("insert into emps values('arun3','sales',150000)")
    cur.execute("insert into emps values('arun4','sales',150000)")

    con.commit()
    cur.execute("Select * from emps")
    for record in cur.fetchall():
      print(record)
    con.close() 
except sqlite3.Error as e:
    print("Some ERror")
    print(e)
==========================================================================

Functions:-
===========
>> Functions are objects  = __name__/__doc__/__defaults__/__closure__
>> fns has to defined before its called - Interpreter
>> fns can return multiple values       - Tuple
>> var defined within fn by default     - Local
>> There is no ARGUMENT Type checking

>> docstrings
>> special functions - globals()/locals()
>> call by value/call by reference
>> global keyword
>> positional/default/keyword arguments
>> variable args
>> one liner fns - lambda expressions
>> Nested Functions


ex1:
=====
def add(v1=0,v2=0):
   '''this is the help for
   the function
   which adds 2 nos'''
   res = v1 + v2
   print("Local = ",locals())
   print("global = \n",globals())
   return res


print(__name__)
res = add
print(res)
print(type(res))
print(res.__name__)
print(res.__defaults__)
print(res.__doc__)
print(res.__closure__)






 

ex2:-
======
>> how many copy of variable "num" are there - 2
>>  - local copy
>>  - global copy

def callme():
  num=5555
  print("In fun = ",num)  



num=10
print("BEfore = ",num)
callme()                # i am NOT passing num
print("AFter = ",num)   # what is the output of this statement ?




ex3:-
=====
>> how many copy of variable "num" are there - 2
>>  - local copy
>>  - global copy
>> how to access global copy of "num"

def callme():
  num=5555
  print("In fun = ",num)  
  print("glb    = ",globals()["num"])


num=10
print("BEfore = ",num)
callme()  # i am NOT passing num
print("AFter = ",num)


ex4:-
=====
>> how to modify the global copy of "num"
   in the function
>> Note: 
     never use globals() function & global keyword together

def callme():
  global num
  num=5555
  print("In fun = ",num)  



num=10
print("BEfore = ",num)
callme()  # i am NOT passing num
print("AFter = ",num)



--------------------------------------------------------------------------

void fun(int *p)
{
  print("%d",*p);
  p = (int*)malloc(4);
  *p=100;
}


int main()
{
 int num=10;
 int *ptr=&num;

 fun(ptr);

 printf("%d %d ",num,*ptr);
}


--------------------------------------------------------------------------
Guess what is the output:-
==========================

def fun(alst):
  alst[0:4] = ["*"] * 4
  

numlst = [10,20,30,40,50,60,70,80]
fun(numlst)
print(numlst)
  

--------------------------------------------------------------------------

>>positional args

def addrecord(name,dept,loc,sal):
  pass

addrecord("arun","sales","blr",15000)  # 
addrecord("arun","sales","blr")        # 
addrecord("arun","sales")              #  
addrecord("arun")                      # 
addrecord()                            # 

>>default args

def addrecord(name=None,dept="accts",loc="blr",sal=0):
  pass

addrecord("arun","sales","blr",15000)  # 
addrecord("arun","sales","blr")        # 
addrecord("arun","sales")              # 
addrecord("arun")                      # 
addrecord()                            # 

>>keyword args

def addrecord(name=None,dept="accts",loc="blr",sal=0):
  pass

addrecord(loc="pune")          # 
addrecord("ajith",sal=15000)   # 



>>variable args

type(args)   - tuple
type(kwargs) - dict
*args & **kwargs is a naming convention

def fun(*args,**kwargs):
  print(args)
  print(kwargs)


fun(1,2,3)
fun(a=10,b=20)
fun(10,20,30,old=25,new=40)
fun()


--------------------------------------------------------------------------
example for nested fns - CLOSURES:-
===================================

>>Nested Functions in python
>>return the address Inner function
>>Inner fn should be using the variables of OUTER

>>Inner-functions is local to Outer-fn - yes/no = yes
>>Can inner-function can access variables of Outer-fn yes/no = yes 

def Outer(a,b):
  v1 = 10
  v2 = 20
  def Inner():
    v3=30
    v4 = a+v1
    print("hello inner = ",v4)
  return Inner

if __name__ == "__main__":
  res1 = Outer(1,2)
  print(res1)
  res1()

  res2 = Outer(55,77)
  print(res2)


ex2:
def Outer(a,b):
  v1 = 10
  v2 = 20
  def Inner():
    v3=30
    v4=a
    print("Locals = ",locals())
    print("hello inner = ",v4)
  return Inner

if __name__ == "__main__":
  res1 = Outer(1,2)
  print(res1)
  res1()

  print(res1.__name__)
  print(res1.__doc__)
  print(res1.__defaults__)
  print(res1.__closure__)

==========================================================================

Guess:-
=======

def fun(alst=[],value=15):
  alst.append(value)
  print("ALST = ",alst)

fun()
fun()
fun()
numlst=[10,20,30,40]
fun(numlst,55) # what will be output here
fun()
fun()    # What will be output here


Note:
what happens if a function has MUTABLE as default argument


==========================================================================
Modules:-
=========
>> Library/API
>> collection of fns/classes/variable
>> every module will have its own name space - same name as filename
>> file extension should be .PY
>> include a module 
       1) import package.moudlename
       2) import modulename
       3) from PACKAGENAME import MODULE
       4) from PACKAGENAME.MODULE import fns/classes
       5) from PACKAGENAME import *
>> imported file will automatically a create a pre-compiled files
   i.e python byte codes - portable
   i.e PYC files 
>> Module search path 
   PYTHONPATH 
    OR
   import sys
   sys.path.append("newpath")

Note: -
 import keyword cannot import a package
 it can only import a module

    import PACKAGENAME   # invalid
    import MODULENAME    # Valid
    import package.module # valid

see later:-
------------
>>what is module constructors in python
>>can we run a module 


mymath.py					another.py
==========					==========

def square(n):					import mymath
  print("MY SYM TAB NAME = ",__name__)
  print("lib square")				mymath.square(5)

def cube(n):
  print("lib cube")

def add(a,b):
  print("lib add")

def minus(a,b):
  print("lib minus")




5 diff ways to import a library:-
=================================

Fully Qualified Name - import keywords
Relative NAmes       - from keyword



import mymath 

import mymath as m

from mymath import *

from mymath import add,minus

from mymath import add as libadd


Note:
 if the function names starts with underscore
 such functions will not be accessible
 only if we import like this

>> from module import *






Problem:-
==========
                            C:\
                             |
        -----------------------------------
       |                                   |
      test				 another
       |                                   |
					  libs
   sample1.py                              |
   -----------                           mymath.py
   import mymath

   mymath.square(5)

   sample2.py
   -----------
   import mymath



   import sys
>> sys.path.append("c:\\another\\libs")  - that particular program
>> PYTHONPATH=c:\another\libs            - env variable all the progs    









Packages:-
==========
 >> it is a FOLDER
 >> is a collection of modules/subpackages
 >> every package should compulsory have a special file named
    __init__.py
 >> python2 users __init__.py contents
    from subpack import *
    __all__=["circle","triangle","subpack"]
 >> from mypack import * 
    this kind of "import" statements requires the
    __init__.py details


                        mypack
                          |
    -------------------------------------------------
   |               |           |                     |
  cirlce.py        |         triangle.py         __init__.py
  ---------        |        ------------         -----------
  def findarea():  |         def findarea():
    pass           |            pass
                   |
                subpack
                   |
          ---------------------
         |                     |
        square.py          __init__.py
        ---------          ------------
        def findarea():
         pass 

===========================================================================


                           Class
                             |
              --------------------------------
             |                                |
          Compile Time                     RunTime

          C++/Java/C#                      Perl/Python

   1) data members has to be        1) we define the data members
      declared                         when required
  
   2) this pointer                  2) self 

   3) implicitly passed - call      3) implicitly passed - call
      implicitly stored - methods      explicitly stored - methods 

   4) constructor chaining          4) ctor chaining - resp programmer

   5) supports overloading          5) does't support overloading

   6) virtual/over-ride             6) all the methods are virtual/override

   7) private/proc/public           7) everything is public








Python Classes:-
==================
>> Run Time Classes - where data members are created at RUNTIME
                    - Monkey Patching
>> Every class should be a subclass of "object" class
>> constructor name in python - def __init__(self)
>> destructor name in python  - def __del__(self)
>> this pointer in python     - self (it not a keyword)
>> py2 - Old Style classes are not a subclass of "object"
       - New Style classes should be a subclass of "object"
>> py3 - New Style classes

mylib.py:-				another.py
==========				==========
class Emps(object)    # py2 		import  mylib
class Emps:           # py3		

  def __init__(self,name,dept,loc,sal):
       print("Ctor called")		e1 = mylib.Emps("adi","sal","blr",
       self.name = name                                       15000)
       self.dept = dept			e2 = mylib.Emps("som","pur","hyd",
       self.loc  = loc					      25000)
       self.sal  = sal			e2.show()
				
  def __del__(self):			e2.updateloc("chn")
       print("Dtor called")
					e2.show()
  def show(self):
       print(self.name)
       print(self.dept)
       print(self.loc)
       print(self.sal)

  def updateloc(self, newloc):
       self.loc = newloc


How to write a class    -  class keyword
object in python        -  dictionary  - dynamic /wastage of memory
slots                   -  fixed data members
                        -  faster
                        -  there is no wastage of memory
constructor             -  def __init__ [ when a object is created ]
destructor              -  def __del__  [ when a object goes out of scope]
this pointer            -  self
access data members     -  self.datamember
private data members    -  start the data memeber name by double underscore
                           self.__datamember
semi private data mem   -  self._datamember [ used by - API Developers ]
public data members     -  self.datamember
private methods         -  def __methodname(self)
static data members     -  classname.DATAMEMBER
static methods          -  @staticmethod
operator overloading    -  designated methods defined
                           def __add__(a,b) 
                           def __minus__(a,b)
inheritance             -  class Derived(BASECLASSNAME):
                        -  constructor chaining is not there in py classes
method over riding      -  classname.OVERRIDDEN_METHODNAME(self)
                           super().OVERRIDDEN_METHOD()
property/descriptors    -  def getattr() / def setattr() / def delattr()

duck typing             -


example for slots:-
===================
>>> class sample(object):
...   __slots__=["name","dept"]
...   def __init__(self,a,b):
...    self.name=a
...    self.dept=b
...
>>> s1 = sample("arun","sales")
>>> s1.name
'arun'
>>> s1.dept
'sales'
>>> s1.loc="blr"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'sample' object has no attribute 'loc'
>>>

example for static data members & Static methods:-
==================================================
class Product:

   total=0    ####### STATIC DATA MEMBER declared ######   

   def __init__(self,name,catg,stock,unitprice):
     self.name=name
     self.catg=catg  
     self.stock=stock
     self.price=unitprice
     Product.total = Product.total + self.stock
   
   def show(self):
     pass
    
   @staticmethod            #### Syntax for defining a static method###
   def displaytotal():  
     print("Total = ",Product.total)

Product.displaytotal()
p1 = Product("DVD","storage",500, 15)
p2 = Product("CPU","PC",150,5600)
Product.displaytotal()


Operator Overloading:-
======================
>>Every operator is a method of a class

a+b   def __add__(self,other)
a-b   def __sub__(self,other)
a*b   def __mul__(self,other)
a/b   def __truediv__(self,other)

a==b  def __eq__(self,other)
a!=b  def __ne__(self,other)
a>b   def __gt__(self,other)   
a>=b  def __ge__(self,other)
a<b   def __lt__(self,other)
a<=b  def __le__(self,other)


a=10
b=20
c = a + b # int.__add__(a,b)

a=[1,2,3]
b=[5,6,7]

c = a+b   # list.__add__(a,b)


class Emps:

   def __init__(self,name,dept):
      self.name = name
      self.dept = dept

   def show(self):
      print(self.name,self.dept)

   def __eq__(self,other):
      print("hai i am been called.....")
      return self.name == other.name


e1 = Emps("arun","purch")
e2 = Emps("raja","hrd")

if e1==e2:      # Emps.__eq__(e1,e2)
  print("Same names")
else:
  print("Diff names")


example for Inheritance:-
=========================

class Alpha:
  def __init__(self,value1):
    self.value1 = value1

  def show1(self):
    print("ALpha = ",self.value1)

class Beta(Alpha):     ####### how to inherit classes in python #######
  def __init__(self,value1,value2):
    Alpha.__init__(self,value1)   ###### Ctor chaining #####
    self.value2= value2

  def show2(self):
    print("BEta = ",self.value2) 
   
 
ob1 = Beta(10,20)
ob1.show1()
ob1.show2()

example method over-riding:-
============================
class Alpha:
  def __init__(self,value1):
    self.value1 = value1

  def show(self):                   ####### base class show() #######
    print("ALpha = ",self.value1)

class Beta(Alpha):     
  def __init__(self,value1,value2):
    Alpha.__init__(self,value1)   
    self.value2= value2

  def show(self):		   ###### derived class show() ########
    super().show()                 ####  invoking a over-ridden method##
    print("BEta = ",self.value2) 
   
 
ob1 = Beta(10,20)
ob1.show()


example for property:-
======================

class Emps:

  def __init__(self,name):
     self.name = name   

  def getname(self):
     return self._name

  def setname(self,newname):
     if newname.isalpha():
        self._name=newname
     else:
        self._name=None  
  name=property(getname,setname)
  

e1 = Emps("arun")
print(e1.getname())
e1.name="123456"
print(e1.getname())


=========================================================================
Special Types:-
===============
Iterators:-
===========
>> user defined classes can iterable/iterator
   by over-riding 2 special methods

   def __iter__(self)
   def __next__(self)  # py3
   def next(self)      # py2

ex1:-
=====
class Team:
   
  def __init__(self,name,members):
    self.name=name
    self.members=members

  def show(self):
    print(self.name,self.members)

  def __iter__(self):
    return iter(self.members)
     

t1 = Team("Design",["ranjith","pavan","harish","manish"])
t1.show()

for member in t1:
  print("Hello",member)


ex2:
=====
class Team:
   
  def __init__(self,name,members):
    self.name=name
    self.members=members
    self.counter=0

  def show(self):
    print(self.name,self.members)

  def __iter__(self):
    return self

  def __next__(self):
   self.counter+=1
   if self.counter <= len(self.members):
    return self.members[self.counter-1]
   else:
    raise StopIteration("MEmnbers over flow")
      
    
t1 = Team("Design",["ranjith","pavan","harish","manish"])
for elem in t1:
  print(elem)






Generator:-
===========
>> any function/method which uses a keyword "yield"
   such function when called they return a "generator object"

>> yield keyword - is like return, except return exits the function
                   but yield preserves the previous state of the object
                   exits the function after the last yield

>> cannot use yield & return together in a function

>> generator-object starts the execution of the function only 
   when they are iterated

>> lazy execution model

def fun():
 print("Fun started")
 yield 10
 yield 20
 yield 30
 yield 40
 print("Fun ended")

print(list(fun())

for elem in fun():
  print(elem)

print(*fun()):

res = fun()
print(next(res))



Decorator:-
===========
>> We need to add some common code , having access to its local variables
   to be executed before & After the actual code

>> without changing the calling convention

test.py
=======
import intellib

intellib.start()


intellib.py			
============
def Outer(fnref):
  def Inner(*args,**kwargs):
    print("What activity to execute before....")
    res = fnref(*args,**kwargs)
    print("What activity to execute after.....")
    return res
  return Inner

@Outer
def start(host,user,pwd):
  pass

def stop():
  pass

@outer
def cleanup(device):
  pass

@outer
def process(commands,host):
  pass


==========================================================================
Exception :-
============
>> s/w interrupts in the program - Exceptions
   Run Time Errors
>> Implicit Exception Handler
    - compiler
    - abrupt exit
    - there is no cleanup
    - programmers lost the control

>> Explicit Exception Handler
    - programmers
    - clean exit
    - cleanup is done
    - programmers gets the control back   
    - keywords - try/except/else/finally
               - "throw" equivalent in python - "raise"
>> "throw"    - raise IndexError("sample")

>> Exception Hierarchy -

                       BaseException
                            |
   ---------------------------------------------------------
  |                  |              |                       |
 Exception     SystemExit      GeneratorExit    KeyBoardInterrupt


Note: 
for programmer the base class would be "Exception" class

Syntax:
=======

try:

   block

except ValueError as e1:
   block
except IndexError as e1:
   block
except:             ### generic catch block#####
   block
else:               #### when there is no exceptions - optional
   block
finally:            #### always  - optional
   block



example:-
=========
import traceback
import sys

class ZeroError(Exception):
  def __init__(self,mesg):
    Exception.__init__(self)
    self.mesg = mesg
  
  def __str__(self):   # toString eq of java
    return self.mesg

try:
    num1 = input("Enter u r value : ")
    num1 = int(num1)
    if num1==0:
       raise ZeroError("Value cannot be zero......")
except ValueError as e1:
    print("Action-1",e1)
except ZeroError as e2:
    print("Action-2",e2)
except:
    print("DEfault")
    traceback.print_exc()
    print(sys.exc_info())    


===========================================================================
Function Programming:-
======================
>> libarary are - functools/itertools

1) lambda expressions

2) map algorithm  - expression returns value

3) filter algo    - expression returns boolean

4) reduce algo   -

5) list comp     - alst=[int(elem) for elem in strlst]

6) dict comp     - a = {e1:e2 for e1,e2 in zip(keylst,vallst)}

7) generator comp- genit =(int(elem) for elem in strlst)

8) partial functions


example for partial fns:-
=========================
from functools import partial

def power(number,raisedto):
  res = number ** raisedto
  return res

square = partial(power,raisedto=2)
cube   = partial(power,raisedto=3)
print(square(5))
print(cube(5))






ex:-
import itertools

numlst =[10,20,30,40,50,60,70,80,90,100,110]

incrlst=[1,2,3]

res = map(lambda x,y : x+y , numlst, itertools.cycle(incrlst))

print(list(res))



Dynamic Code Evaluation:-
=========================

i have a json file:-
--------------------
some.json
=========
{ "name" : "ajith",
  "dept" : "IMS",
  "loc"  : "blr"
}



f1 = open("some.json","r")

empdict = eval(f1.read())

f1.close()

print(type(empdict))

print(empdict)

ex2:

num1=10
num2=15
num3=20
num4=25
num5=30

for i in range(1,6):
   print(eval("num"+str(i)))


see later:-
===========
eval()
exec()
==========================================================================
Concurrency:-
=============
import multiprocessing - Process
import threading       - Thread
import subprocess
import concurrent



prog1.py:-
==========
import threading 
import os
import time

def job1():
  print("JOB1 - PID = ",os.getpid())
  time.sleep(5)
  
def job2():
  print("JOB2 - PID = ",os.getpid())
  time.sleep(3)

def job3():
  print("JOB3 - PID = ",os.getpid())
  time.sleep(6)

if __name__ == "__main__":
  t1 = threading.Thread(target=job1,args=())
  t2 = threading.Thread(target=job2,args=())
  t3 = threading.Thread(target=job3,args=())
  start = time.time()
  t1.start()
  t2.start()
  t3.start()
  t1.join()
  t2.join()
  t3.join()
  end = time.time()
  print("Time took = ",end-start)






ex2:
import threading 
import os
import time

def job1(lck):
  lck.acquire()
  print("JOB1 - PID = ",os.getpid())
  lck.release()
  time.sleep(5)
  
def job2(lck):
  print("JOB2 - PID = ",os.getpid())
  time.sleep(3)

def job3(lck):
  print("JOB3 - PID = ",os.getpid())
  time.sleep(6)

if __name__ == "__main__":
  lck = threading.Lock()
  t1 = threading.Thread(target=job1,args=(lck,))
  t2 = threading.Thread(target=job2,args=(lck,))
  t3 = threading.Thread(target=job3,args=(lck,))
  start = time.time()
  t1.start()
  t2.start()
  t3.start()
  t1.join()
  t2.join()
  t3.join()
  end = time.time()
  print("Time took = ",end-start)


ex3:
=====
import multiprocessing
import os
import time

def job1():
  print("JOB1 - PID = ",os.getpid())
  time.sleep(5)
  
def job2():
  print("JOB2 - PID = ",os.getpid())
  time.sleep(3)

def job3():
  print("JOB3 - PID = ",os.getpid())
  time.sleep(6)

#####***** THIS check is compulsory*******#####
if __name__ == "__main__":
  t1 = multiprocessing.Process(target=job1,args=())
  t2 = multiprocessing.Process(target=job2,args=())
  t3 = multiprocessing.Process(target=job3,args=())
  start = time.time()
  t1.start()
  t2.start()
  t3.start()
  t1.join()
  t2.join()
  t3.join()
  end = time.time()
  print("Time took = ",end-start)



Note:-
=======
IPCs
 rabbitMQ

 MessageQ
 SharedMemory
 FIFO
 sockets

 Semaphore
 mutex


--------------------------------------------------------------------------
ex:-
====
import time
import multiprocessing 

def square(num):
  time.sleep(1)
  return num*num

if __name__ == "__main__":
 numlst = list(range(1,101))
 p = multiprocessing.Pool(10)
 start = time.time()
 reslst = p.map(square, numlst)
 end = time.time()  
 print("Time took = ",end-start)
 p.close()
 print(reslst[:10])

--------------------------------------------------------------------------
I want to execute a shell command in python
& i need was it success/failure

import os

status = os.system("command")
print(status)  # 0/non-zero


I want to execute a shell command in python
& i need output of the command

import subprocess

result = subprocess.check_output("ipconfig")

print(result)


--------------------------------------------------------------------------
see later:-
===========
subprocess.Popen
subprocess.PIPE

ls -l | grep "^d" | wc -l

--------------------------------------------------------------------------
Core Libs:-
===========
>> they are preinstalled with the compiler

glob    - wild card matching on the files
          import glob

          flst = glob.glob("*.txt")
          print(flst)
 
logging -
          import logging
          
          logging.basicConfig(level=logging.DEBUG,filename="err.log")

          logging.debug("a")
          logging.info("b")
          logging.warning("c")         #### default level #####
          logging.error("d")
          logging.critical("e")


os      - interface the underlying OS

          import os

          print(os.name)
          print(os.getpid())
          print(os.getcwd())
          print(os.environ["PATH"])
          if os.path.isfile("one.txt")
          
          os.system("command")
          os.remove("one.txt")


sys     - interface with python Interpreter

          import sys

          print(sys.version)
          print(sys.platform)
          print(sys.path)


re      - import  re

          name = input("Enter u r name : ")
          if re.search("^a.*a$", name):
              print("yes")
          else:
              print("no")

\d = [0-9]
\s = spaces
\w = alphanumeric

integer check = re.search("^\d+$", string)
float check   = re.search("^\d+\.\d+$", string)
str 2 words   = re.search("^\w+\s\w+$",string)
dd-mm-yyyy    = re.search("^\d{2}-\d{2}-\d{4}$",string)

see later:-
===========
re.search
re.match
re.split
re.sub
re.findall
re.finditer
re.compile


Tools:-
=======
test   - unittest
       - pytest3
       - nose

ex1
import mathlib   # library to test
import unittest 


class Mytest(unittest.TestCase):
   
  def setUp(self):
     #all u r fixture has to set here
     
  def tearDown(self):
     # release all the fixtures

  def test_add(self):
     self.assertEquals(mathlib.add(10,20),30)

  def test_minus(self):
     self.assertEquals(mathlib.minus(20,20),0)

  def test_divide(self):
     self.assertEquals(mathlib.divide(5,2),2.5)

  def test_multiply(self):
     self.assertEquals(mathlib.multiply(2,2),4)
    
 
if __name__ == "__main__":
  unittest.main()


ex2:-
======
C:\> pip install pytest3



test_some.py
============
from mathlib import *

def test_add():
  assert add(10,20)==20



C:\> pytest3 test_some.py





Debug:-
=======
CLI debugging
GUI debugging
Debug Server   - apply break points in the program


ex:
====
import pdb

def fun(a,b):
    pdb.set_trace()
    print("hello",a,b)
    a=10
    for i in range(10):
        a+=1
    print("bye")

def greet():
    print("Hello world")

print("Hello from main")
greet()
fun(10,20)
print("Sime stat")
fun(1,2)
print("bye from main")


ex2:

C:\> python -m pdb  program1.py

l - list program with line number

b 20  
b start
b 35 value==40
tbreak 45

b       - list all the break points

cl      - clear the break points
enable
disable

s/n     - step in & step over

p alst  - print the value

c       - continue

up
down
bt
whatis
where
jump


doc
install
distribute

setup.py
========
from distutils.core import setup

setup(name='mymath',
      version='1.0',
      py_modules=['mymath'],
      )


C:\> python setup.py  --sdist
C:\> python setup.py  --sdist  --help-formats

[ i will create a folder named "dist"
  under that folder there will be a filenamed
  mymath.1.0.zip
]

Old formats:- eggmodules/wheel modules

NLTK

pyGame

ML:-
====
sckitlearn
scipy
imaging

Data anal:-
===========
pandas/matplotlib/xl/....
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv("emps.csv")
print(df)
df.plot()
plt.show()